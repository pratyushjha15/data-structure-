                                                                              DATA STRUCTURE

                                              //LAB-1//
(q1 part -1)

#include <stdio.h>
// void InsertEmpty(int *arr, int num){
//     arr[0] = num;
// }
void InsertFirst(int *arr, int num){
    for(int i=10; i>0; i--){
        arr[i] = arr[i-1];
    }
    arr[0] = num;
}
void InsertLast(int *arr, int num){
    for(int i=0; i<10; i++){
       if(arr[i] == 0){
           arr[i] = num;
           break;
       }
    }
}

int main() {
    int arr[10] = {11,12,13,14,15};
    //InsertEmpty(arr, 1);
    InsertFirst(arr, 10);
    for(int i=0; i<10; i++){
       printf("%d ", arr[i]);
    }
    printf("\n");
    InsertLast(arr, 50);
    for(int i=0; i<10; i++){
       printf("%d ", arr[i]);
    }

    return 0;
}

(q1 part 2)

#include <stdio.h>
void InsertEmpty(int *arr, int first, int last){
    arr[0] = first;
    arr[1] = last;
    printf("%d %d", first, last);
}
int main() {
    
    int arr[]={0};
    InsertEmpty(arr, 12, 155);
    return 0;
}

q2)


Q3)


Q4)


//////  SORTING IN ASCENDING ORDER ////

#include <stdio.h>    
     
int main()    
{      
    int arr[] = {50, 20, 80, 70, 10};     
    int temp = 0;    
           
    int length = sizeof(arr)/sizeof(arr[0]);    
         
    printf("Elements of original array: \n");    
    for (int i = 0; i < length; i++) {     
        printf("%d ", arr[i]);     
    }      
         
    for (int i = 0; i < length; i++) {     
        for (int j = i+1; j < length; j++) {     
           if(arr[i] > arr[j]) {    
               temp = arr[i];    
               arr[i] = arr[j];    
               arr[j] = temp;    
           }     
        }     
    }    
        
    printf("\n");    
            
    printf("Elements of array sorted in ascending order: \n");    
    for (int i = 0; i < length; i++) {     
        printf("%d ", arr[i]);    
    }    
    return 0;    
}     


///  LARGETS AND SECOND LARGEST /////

#include <stdio.h>
int main ()
{
    int n = 0, i = 0, largest1 = 0, largest2 = 0, temp = 0;
 
    printf ("Enter the size of the array\n");
    scanf ("%d", &n);
    int array[n];
    printf ("Enter the elements\n");
    for (i = 0; i < n; i++)
    {
        scanf ("%d", &array[i]);
    }
 
    printf ("The array elements are : \n");
    for (i = 0; i < n; i++)
    {
        printf ("%d\t", array[i]);
    }
 
    printf ("\n");
 
    largest1 = array[0];
    largest2 = array[1];
 
    if (largest1 < largest2)
    {
        temp = largest1;
        largest1 = largest2;
        largest2 = temp;
    }
 
    for (int i = 2; i < n; i++)
    {
        if (array[i] > largest1)
        {
            largest2 = largest1;
            largest1 = array[i];
        }
        else if (array[i] > largest2 && array[i] != largest1)
        {
            largest2 = array[i];
        }
    }
 
    printf ("The FIRST LARGEST = %d\n", largest1);
    printf ("THE SECOND LARGEST = %d\n", largest2);
 
    return 0;
}

////  REVERSE OF ARRAY ////

#include<stdio.h>  
void reverse(int l, int h, int arr[]);  
void display(int arr[], int n);  
int main()  
{  
    int n, i;  
    printf("Enter the size of the array: ");  
    scanf("%d", &n);  
    int arr[n];  
    printf("Enter the elements: ");  
    for(i = 0; i < n; i++)  
    {  
        scanf("%d", &arr[i]);  
    }  
    int l = 0, h = n - 1;  
    reverse(l, h, arr);  
    printf("The reversed array: ");  
    display(arr, n);  
    return 0;  
}  
void reverse(int l, int h, int arr[])  
{  
    if(l >= h)  
    {  
        return;  
    }  
    int temp;  
    temp = arr[l];  
    arr[l] = arr[h];  
    arr[h] = temp;  
    reverse(l + 1, h - 1, arr);  //recursive call  
}  
void display(int arr[], int n)  
{  
    int i;  
    for(i = 0; i < n; i++)  
    {  
        printf("%d ", arr[i]);  
    }  
}  







                                                                                //LAB-2//

q1)
Print the Elements of a Linked List

void printLinkedList(SinglyLinkedListNode* head) 
 {
    SinglyLinkedListNode *temp=head;
    while(temp!=NULL)
    {
        printf("%d\n",temp->data);
        temp=temp->next;
    }
}
q2)
Insert a Node at the Tail of a Linked List

SinglyLinkedListNode* insertNodeAtTail(SinglyLinkedListNode* head, int data) {

     SinglyLinkedListNode* node = (SinglyLinkedListNode*)malloc(sizeof(SinglyLinkedListNode));
    node->data = data;
    node->next = NULL;
    if(head==NULL){
        head = node;
    }
    else{
        SinglyLinkedListNode* temp = head;
        while(temp->next != NULL){
            temp = temp->next;
            
        }
        temp->next = node;
        
    }
    return head;
     
    }

q3)
Insert a node at the head of a linked list
SinglyLinkedListNode* insertNodeAtHead(SinglyLinkedListNode* llist, int data) {

    SinglyLinkedListNode *temp = llist , *newNode;
    
    if((temp == NULL))
    {
        llist = create_singly_linked_list_node(data);
        return llist;
        
    }
    else
        {
    newNode = create_singly_linked_list_node(data);
    newNode->next = temp;
    llist = newNode;
    return llist;
        }
}

q4)
Insert a node at a specific position in a linked list


SinglyLinkedListNode* insertNodeAtPosition(SinglyLinkedListNode* head, int data, int position) {
    
    SinglyLinkedListNode* newNode = new SinglyLinkedListNode(data);
    
    
    if (position == 0) {
        newNode->next = head;
        return newNode;
    }

    
    SinglyLinkedListNode* current = head;
    for (int i = 0; i < position - 1; ++i) {
        if (current == nullptr) {
            
            return head;
        }
        current = current->next;
    }

   
    newNode->next = current->next;
    current->next = newNode;
    
    return head;
}


q5)
Delete a Node

SinglyLinkedListNode* deleteNode(SinglyLinkedListNode* llist, int position) {

    
    SinglyLinkedListNode* prev;
    SinglyLinkedListNode* temp = llist;

    
    if (temp == NULL)
        return llist;


    if (position == 0) {
        
        llist = temp->next;
        free(temp);
        return llist;
    }

    
    for (int i = 0; i != position; i++) {
        prev = temp;
        temp = temp->next;
    }

   
    if (temp != NULL) {
        prev->next = temp->next;
        free(temp);
    }
   
    else {
        cout << "Data not present\n";
    }

    return llist;
}

q6)
Print in Reverse

void reversePrint(SinglyLinkedListNode* llist) {
    if(llist==NULL){
        return;
        
    }
    reversePrint(llist->next);
    printf("%d\n",llist->data);
}
   

------------------------------------------------------------------------------------------------------------------------
    \\ lab - 3 \\
##  LINKED LIST   ##
------------------------------------------------------------------------------------------------------------------------
q1)  Inserting a Node Into a Sorted Doubly Linked List

DoublyLinkedListNode* sortedInsert(DoublyLinkedListNode* llist, int data){
    DoublyLinkedListNode* newNode= new DoublyLinkedListNode(data);
    if (llist==nullptr){
        return newNode;
    }
    if (data<=llist->data){
        newNode->next = llist;
        llist->prev = newNode;
        return newNode;
    }
      DoublyLinkedListNode*current = llist;
    while(current->next!=nullptr &&  current->next->data < data){
        current = current->next;
    }
        newNode->next = current->next;
        if(current->next!= nullptr){
            current->next->prev = newNode;
        }
         current->next = newNode;
          newNode->prev = current;

    return llist;
}

q2)  Reverse a doubly linked list

DoublyLinkedListNode* createNode(int data){
    DoublyLinkedListNode* newNode = (DoublyLinkedListNode*)malloc(sizeof(DoublyLinkedListNode));
newNode->data = data;
newNode->next = NULL;
newNode->prev = NULL;
return newNode;

}
DoublyLinkedListNode* reverse(DoublyLinkedListNode* head){
    DoublyLinkedListNode*temp=NULL;
    DoublyLinkedListNode*current=head;
    
     while (current != NULL){
          temp = current->prev;
          current->prev = current->next;
           current->next = temp;
          current= current->prev;
     }
    if (temp != NULL){
        head = temp->prev;
        
    }
    return head;
}

q3)   Cycle Detection

bool has_cycle(SinglyLinkedListNode* head) {
if (head == nullptr) {
    return false;
}
    SinglyLinkedListNode* slow = head;
    SinglyLinkedListNode* fast = head;
    while (fast != nullptr && fast->next != nullptr){
        slow = slow->next;
        fast = fast->next->next;
        
        if (slow == fast) {
            return true;
            
        }
        
    }
    return false;
}

q4)  Delete duplicate-value nodes from a sorted linked list

SinglyLinkedListNode* removeDuplicates(SinglyLinkedListNode* llist) {
if (llist == nullptr){
    return nullptr;
}
    SinglyLinkedListNode* current = llist;
    while (current != nullptr) {
     SinglyLinkedListNode* temp = current;
        while (temp->next != nullptr) {
            if (temp->next->data == current->data) {
                SinglyLinkedListNode* duplicate = temp->next;
                temp->next = temp->next->next;
                delete duplicate;
            }
            else{
                temp = temp->next;
            }
        
            }
        current= current->next;
        }
    return llist;
}

q5)  Merge two sorted linked lists

SinglyLinkedListNode* mergeLists(SinglyLinkedListNode* head1, SinglyLinkedListNode* head2) {
SinglyLinkedListNode dummy(0);
SinglyLinkedListNode*tail = &dummy;
SinglyLinkedListNode*current1 = head1;
    SinglyLinkedListNode*current2 = head2;
    while (current1 != nullptr && current2 != nullptr) {
        if (current1->data <= current2->data) {
            tail->next = current1;
            current1 = current1->next;
        }else{
            tail->next = current2;
            current2 = current2->next;
        }
        tail = tail->next;
            
    }
     if (current1 != nullptr) {
tail->next = current1;
         }else if(current2 !=nullptr){
         tail->next= current2;
         
     }
return dummy.next;
}

----------------------------------------------------------------------------------------------------------------------------
